def quick_sort(arr):
    """
    Сортирует список arr алгоритмом быстрой сортировки (QuickSort).

    Args:
        arr: Список, который нужно отсортировать.

    Returns:
        Отсортированный список (новый список).
    """
    if len(arr) <= 1:
        return arr  # Базовый случай: пустой или одноэлементный список уже отсортирован

    pivot = arr[len(arr) // 2]  # Выбираем опорный элемент (pivot) - в данном случае, середина списка.  
                                 # Можно выбирать pivot разными способами (первый элемент, случайный элемент и т.д.)

    less = [i for i in arr if i < pivot]   # Создаем список элементов, меньших, чем pivot
    equal = [i for i in arr if i == pivot]  # Создаем список элементов, равных pivot
    greater = [i for i in arr if i > pivot] # Создаем список элементов, больших, чем pivot

    # Рекурсивно сортируем подсписки less и greater и объединяем их с equal
    return quick_sort(less) + equal + quick_sort(greater)



# **************************************************************************
# Ниже представлена версия QuickSort, сортирующая "на месте" (in-place).
# Она изменяет исходный список, вместо создания нового.
# Эта версия обычно более эффективна по памяти, но немного сложнее в реализации.
# **************************************************************************


def quick_sort_in_place(arr, low, high):
    """
    Сортирует список arr алгоритмом быстрой сортировки "на месте" (in-place).

    Args:
        arr: Список, который нужно отсортировать.  Изменяется непосредственно.
        low: Индекс начала сортируемого участка списка.
        high: Индекс конца сортируемого участка списка.
    """
    if low < high:  # Базовый случай: если участок списка содержит менее двух элементов, он уже отсортирован

        pi = partition(arr, low, high) # Разбиваем список на две части относительно pivot (индекс pi)

        quick_sort_in_place(arr, low, pi-1)  # Рекурсивно сортируем левую часть
        quick_sort_in_place(arr, pi+1, high) # Рекурсивно сортируем правую часть


def partition(arr, low, high):
    """
    Разбивает список arr на две части относительно опорного элемента (pivot).

    Args:
        arr: Список, который нужно разбить.
        low: Индекс начала участка списка.
        high: Индекс конца участка списка.

    Returns:
        Индекс опорного элемента (pivot) после разбиения.
    """
    pivot = arr[high]  # Выбираем последний элемент в качестве опорного (pivot)
    i = (low - 1)      # Индекс меньшего элемента

    for j in range(low, high):  # Итерируемся по списку от low до high-1
        if arr[j] <= pivot:   # Если текущий элемент меньше или равен pivot

            i = i + 1          # Увеличиваем индекс меньшего элемента
            arr[i], arr[j] = arr[j], arr[i]  # Меняем местами arr[i] и arr[j]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # Меняем pivot с элементом arr[i+1]
    return (i + 1)  # Возвращаем индекс pivot